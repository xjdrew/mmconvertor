/*
	convert MaxMind GeoLite Country data to a golang map
	data source: http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip
*/
package main

import (
	"bytes"
	"encoding/csv"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"sort"
	"strconv"
)

var packageName, varibleName string

type CountryIP struct {
	Name  string
	Start uint32
	End   uint32
}

type CountryIPs []*CountryIP

func (c CountryIPs) Len() int           { return len(c) }
func (c CountryIPs) Less(i, j int) bool { return c[i].End < c[j].End }
func (c CountryIPs) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }

func generateSource(networks CountryIPs) []byte {
	b := new(bytes.Buffer)

	// file header
	b.WriteString("// Code generated by mmconvertor.\n")
	b.WriteString("// mmconvertor: github.com/xjdrew/mmconvertor.\n")
	b.WriteString("// DO NOT EDIT!\n")
	b.WriteString("\n")

	// package
	b.WriteString(fmt.Sprintf("package %s\n", packageName))

	// variable
	b.WriteString(fmt.Sprintf(`var %s = []struct{
	Name string
	Start  uint32
	End    uint32}{`, varibleName))
	for _, n := range networks {
		b.WriteString(fmt.Sprintf("{%q,%d,%d},\n", n.Name, n.Start, n.End))
	}
	b.WriteString("}")

	data, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	return data
}

func convertToCountryIP(record []string) (*CountryIP, error) {
	if len(record) != 6 {
		return nil, fmt.Errorf("invalid record format:%v", record)
	}

	ip1, err := strconv.ParseInt(record[2], 10, 64)
	if err != nil {
		return nil, err
	}

	ip2, err := strconv.ParseInt(record[3], 10, 64)
	if err != nil {
		return nil, err
	}

	name := record[4]

	return &CountryIP{
		Name:  name,
		Start: uint32(ip1),
		End:   uint32(ip2),
	}, nil
}

func main() {
	flag.StringVar(&packageName, "package", "main", "package name")
	flag.StringVar(&varibleName, "variable", "geoIP", "variable name")
	file := flag.String("file", "GeoIPCountryWhois.csv", "csv format MaxMind GeoLite Country data")
	flag.Parse()

	inputFile := *file
	if inputFile == "" {
		inputFile = flag.Arg(0)
	}

	f, err := os.Open(inputFile)
	if err != nil {
		log.Fatal("open: ", err)
	}

	var networks CountryIPs
	r := csv.NewReader(f)
	for {
		record, err := r.Read()
		if err == io.EOF {
			break
		}

		if err != nil {
			log.Fatal("csv: ", err)
		}

		network, err := convertToCountryIP(record)
		if err != nil {
			log.Fatal("convert:", err)
		}
		networks = append(networks, network)
	}

	sort.Sort(networks)

	data := generateSource(networks)
	if _, err = os.Stdout.Write(data); err != nil {
		log.Fatal(err)
	}
}
