/*
	convert MaxMind GeoLite Country data to a golang map
	data source: http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip
*/
package main

import (
	"bytes"
	"encoding/csv"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strconv"
)

var packageName, varibleName string

type CountryIP struct {
	Name  string
	Start int
	End   int
}

func generateSource(networks []*CountryIP) []byte {
	b := new(bytes.Buffer)

	// file header
	b.WriteString("// Code generated by mmconvertor.\n")
	b.WriteString("// mmconvertor: github.com/xjdrew/mmconvertor.\n")
	b.WriteString("// DO NOT EDIT!\n")
	b.WriteString("\n")

	// package
	b.WriteString(fmt.Sprintf("package %s\n", packageName))

	// variable
	b.WriteString(fmt.Sprintf(`var %s = []struct{
	Name string
	Start  int
	End    int}{`, varibleName))
	for _, n := range networks {
		b.WriteString(fmt.Sprintf("{%q,%d,%d},\n", n.Name, n.Start, n.End))
	}
	b.WriteString("}")

	data, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	return data
}

func convertIntToBytes(v int) []byte {
	var ret [4]byte
	ret[0] = byte(v >> 24)
	ret[1] = byte(v >> 16)
	ret[2] = byte(v >> 8)
	ret[3] = byte(v)
	return ret[:]
}

func convertToCountryIP(record []string) (*CountryIP, error) {
	if len(record) != 6 {
		return nil, fmt.Errorf("invalid record format:%v", record)
	}

	ip1, err := strconv.Atoi(record[2])
	if err != nil {
		return nil, err
	}

	ip2, err := strconv.Atoi(record[3])
	if err != nil {
		return nil, err
	}

	name := record[4]

	return &CountryIP{
		Name:  name,
		Start: ip1,
		End:   ip2,
	}, nil
}

func main() {
	flag.StringVar(&packageName, "package", "main", "package name")
	flag.StringVar(&varibleName, "variable", "geoIP", "variable name")
	file := flag.String("file", "GeoIPCountryWhois.csv", "csv format MaxMind GeoLite Country data")
	flag.Parse()

	inputFile := *file
	if inputFile == "" {
		inputFile = flag.Arg(0)
	}

	f, err := os.Open(inputFile)
	if err != nil {
		log.Fatal("open: ", err)
	}

	var networks []*CountryIP
	r := csv.NewReader(f)
	for {
		record, err := r.Read()
		if err == io.EOF {
			break
		}

		if err != nil {
			log.Fatal("csv: ", err)
		}

		network, err := convertToCountryIP(record)
		if err != nil {
			log.Fatal("convert:", err)
		}
		networks = append(networks, network)
	}

	data := generateSource(networks)
	if _, err = os.Stdout.Write(data); err != nil {
		log.Fatal(err)
	}
}
